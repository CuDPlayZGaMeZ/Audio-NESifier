<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NES Audio Bitcrusher</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #111;
      color: #eee;
      text-align: center;
      padding: 2rem;
    }
    h1 { color: #ffcc00; }
    .card {
      max-width: 720px;
      margin: 0 auto;
      background: #1a1a1a;
      border-radius: 12px;
      padding: 1.25rem;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .row { margin: 1rem 0; }
    input[type="file"] {
      display: inline-block;
      padding: 0.5rem;
      background: #222;
      border-radius: 8px;
      border: 1px solid #333;
      color: #bbb;
    }
    button {
      margin: 0.5rem;
      padding: 0.65rem 1.1rem;
      border-radius: 10px;
      border: none;
      background: #ff6600;
      color: white;
      cursor: pointer;
      font-weight: bold;
    }
    button:hover { background: #ff8533; }
    .hint { color: #aaa; font-size: 0.9rem; }
    .controls { display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; }
    .control { background:#222; padding:0.75rem 1rem; border-radius:10px; }
    label { display:block; font-size:0.85rem; color:#bbb; margin-bottom:0.25rem; }
    input[type="number"] { width: 80px; padding: 0.3rem; border-radius:6px; border:1px solid #333; background:#111; color:#eee; }
    footer { margin-top: 1rem; color:#777; font-size:0.85rem; }
  </style>
</head>
<body>
  <h1>NES-Style Audio Converter</h1>
  <div class="card">
    <div class="row">
      <input type="file" id="fileInput" accept="audio/*">
    </div>

    <div class="controls row">
      <div class="control">
        <label for="bitDepth">Bit depth (quantization)</label>
        <input type="number" id="bitDepth" value="4" min="2" max="16">
      </div>
      <div class="control">
        <label for="targetRate">Sample rate (Hz)</label>
        <input type="number" id="targetRate" value="11025" min="2000" max="44100" step="1">
      </div>
    </div>

    <div class="row">
      <button id="processBtn">Convert</button>
      <a id="downloadLink" style="display:none;" download="nes_bitcrushed.wav">
        <button>Download WAV</button>
      </a>
    </div>

    <div class="row">
      <h3>Output preview</h3>
      <audio id="outputAudio" controls></audio>
    </div>

    <p class="hint">Tip: NES DPCM vibes = low sample rate (e.g., 8–12 kHz) and low bit depth (e.g., 3–5 bits).</p>
  </div>
  <footer>All processing happens in your browser.</footer>

  <script>
    async function decodeFile(file) {
      const arrayBuffer = await file.arrayBuffer();
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      return new Promise((resolve, reject) => {
        audioCtx.decodeAudioData(arrayBuffer, resolve, reject);
      });
    }

    // Downsample + quantize (bitcrush) into mono
    function downsampleAndQuantize(buffer, targetRate, bitDepth) {
      const sourceRate = buffer.sampleRate;
      const ratio = sourceRate / targetRate;

      // Mixdown to mono
      const channels = [];
      for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
        channels.push(buffer.getChannelData(ch));
      }

      const length = Math.floor(buffer.length / ratio);
      const output = new Float32Array(length);

      let idx = 0;
      let pos = 0;
      while (idx < length) {
        // simple point sampling (nearest)
        const readIndex = Math.floor(pos);
        let sample = 0;
        for (let ch = 0; ch < channels.length; ch++) {
          sample += channels[ch][Math.min(readIndex, channels[ch].length - 1)];
        }
        sample /= channels.length;

        // Quantize to bitDepth
        const levels = Math.pow(2, bitDepth);
        const step = 2 / (levels - 1); // size between -1..1
        const q = Math.round((sample + 1) / step) * step - 1;
        output[idx] = Math.max(-1, Math.min(1, q));

        idx++;
        pos += ratio;
      }

      return { samples: output, sampleRate: targetRate };
    }

    // Convert Float32 mono to WAV (16-bit PCM)
    function floatTo16BitWavMono(float32Array, sampleRate) {
      const numChannels = 1;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const bufferLength = 44 + float32Array.length * bytesPerSample;
      const buffer = new ArrayBuffer(bufferLength);
      const view = new DataView(buffer);

      // RIFF header
      writeString(view, 0, 'RIFF');
      view.setUint32(4, 36 + float32Array.length * bytesPerSample, true);
      writeString(view, 8, 'WAVE');

      // fmt chunk
      writeString(view, 12, 'fmt ');
      view.setUint32(16, 16, true);     // PCM chunk size
      view.setUint16(20, 1, true);      // Audio format = PCM
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, 16, true);     // bits per sample

      // data chunk
      writeString(view, 36, 'data');
      view.setUint32(40, float32Array.length * bytesPerSample, true);

      // samples
      let offset = 44;
      for (let i = 0; i < float32Array.length; i++) {
        let s = Math.max(-1, Math.min(1, float32Array[i]));
        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        offset += 2;
      }

      return buffer;

      function writeString(dv, offset, str) {
        for (let i = 0; i < str.length; i++) {
          dv.setUint8(offset + i, str.charCodeAt(i));
        }
      }
    }

    document.getElementById('processBtn').addEventListener('click', async () => {
      const file = document.getElementById('fileInput').files[0];
      if (!file) return alert('Upload an audio file first!');

      const bitDepth = parseInt(document.getElementById('bitDepth').value, 10);
      const targetRate = parseInt(document.getElementById('targetRate').value, 10);
      if (bitDepth < 2 || bitDepth > 16) return alert('Bit depth must be between 2 and 16.');
      if (targetRate < 2000 || targetRate > 44100) return alert('Sample rate must be between 2000 and 44100 Hz.');

      try {
        const buffer = await decodeFile(file);
        const { samples, sampleRate } = downsampleAndQuantize(buffer, targetRate, bitDepth);
        const wav = floatTo16BitWavMono(samples, sampleRate);

        const blob = new Blob([wav], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);

        const audioElem = document.getElementById('outputAudio');
        audioElem.src = url;

        const dl = document.getElementById('downloadLink');
        dl.href = url;
        dl.style.display = 'inline-block';
      } catch (e) {
        console.error(e);
        alert('Failed to process audio: ' + e);
      }
    });
  </script>
</body>
</html>
